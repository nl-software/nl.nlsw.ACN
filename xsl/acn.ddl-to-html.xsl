<?xml version="1.0" encoding="UTF-8"?>
<!--
 acn.ddl-to-html.xsl

 An XSL-T stylesheet for viewing an ACN Device Description Language Module file via HTML.

 @date 2022-02-08
 @author Ernst van der Pols
-->

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:site="http://ns.nlsw.nl/2010/site"
        xmlns:ddl="http://www.esta.org/acn/namespace/ddl/2008/"
		xmlns:cia="https://www.can-cia.org/CANopen"
		xmlns:krohne="https://www.krohne.com/gdc"
        xmlns:html="http://www.w3.org/1999/xhtml"
        xmlns:exslt="http://exslt.org/common"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        exclude-result-prefixes="exslt site ddl xlink html cia krohne">

<!-- import ACN DDL core template -->
<xsl:import href="acn.ddl.core.xsl"/>

<xsl:output encoding="UTF-8" indent="yes" method="html" version="5.0" doctype-public="" />
<xsl:namespace-alias stylesheet-prefix="html" result-prefix="#default"/>

<xsl:param name="source" select="string('00000000-0000-0000-0000-000000000000.xml')"/>
<!-- $base is the base URI of the xml document (at target location) -->
<xsl:param name="base" select="''" />
<!-- file name extension of target (source) files -->
<xsl:param name="filename-extension" select="'.ddl.xml'" />
<!-- set these paths relative to the target location -->
<xsl:param name="project-path" select="'../'" />
<xsl:param name="ddl-path" select="concat($project-path,'ddl/')" />
<xsl:param name="target-path" select="concat($project-path,'ddl/')" />
<xsl:param name="res" select="concat($project-path,'res/')" />
<xsl:param name="style" select="concat($project-path,'style/')" />
<xsl:param name="images" select="concat($project-path,'data/files/')" />
<xsl:param name="language" select="'en'" />

<xsl:variable name="root" select="/ddl:DDL"/>
<xsl:variable name="title" select="/ddl:DDL/*[1]/ddl:label"/>

<xsl:variable name="expanded-root-device"><xsl:apply-templates select="$root/ddl:device" mode="copy-properties"/></xsl:variable>
<xsl:variable name="enhanced-root-device"><xsl:apply-templates select="exslt:node-set($expanded-root-device)/*" mode="copy-update-address"/></xsl:variable>
<xsl:variable name="root-device-object" select="exslt:node-set($enhanced-root-device)/*"/>

<xsl:template match="/">
<!-- @note using the xmlns="http://www.w3.org/1999/xhtml" on html element cripples rendering in IE -->
<html>
  <xsl:comment> This file is automatically generated. Do not edit. </xsl:comment>
  <head>
    <title><xsl:apply-templates select="$title" mode="text"/></title>
    <meta name="GENERATOR" content="XSLT version {system-property('xsl:version')} processor of {system-property('xsl:vendor')}"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <style type="text/css">
    body { font-family: Calibra, Arial, Helvetica, sans-serif; font-size: smaller; }
    th { text-align:left; vertical-align: top;}
    header { padding: 1ex; }
    header > table > tbody > tr > th { padding-right: 1ex; border-right: 1px solid BurlyWood; text-align: right; font-style: italic; font-weight: normal; white-space: nowrap;}
    footer { border-top: 2px solid BurlyWood; padding-top:4px; }

    body > header { background-color: LemonChiffon; border: 1px solid BurlyWood;}
    section {}
    section + section { margin-bottom: 1ex; }
    section header { background-color: LemonChiffon; border-top: 1px solid BurlyWood; }
    section header h1 { margin: 0; }
    section.appliance { margin-top: 1em; }

    section.behaviordef { border: 1px solid BurlyWood; border-top: none; margin-top: 1em; }
    section.behaviordef section { padding: 1ex 0 0 1ex; background-color:white; }
    section.behaviordef section h4 { margin: 0 0 1ex 0; }

    section.includedev, div.useprotocol,
    section.property { border: 1px solid BurlyWood; margin-top: 1em;}
    section.useprotocol { background-color: OldLace }

    label { cursor: pointer; font-style: italic; }

    main > section > dl {
      background-color: LemonChiffon; border: 1px solid BurlyWood; padding: 1ex; margin-top:0;
    }
    dl dt { cursor: pointer; }
    dl dt > a { margin: 0 1ex 0 0; }
    dl dt span.id { font-weight: bold; margin: 0 1ex 0 0; }
    dl dt.device::before {
      display:inline-block;
      content: "▼"; color: green; width:1em;
    }
    dl dt.device.closed::before { content: "►"; color: green; /*red;*/ }
    dl dt + dd { display: block; margin-left: 1em; }
    dl dt.closed + dd { display: none; }
    dl dt.prop::before {
      display:inline-block;
      content: "\0025FB"; color: green; width:1em; padding-right:1px;
    }
    dl dt.prop {
      position: relative;
    }
    dl dt.prop.NULL::before {
      content: "\0025CB"; /* WHITE CIRCLE */
    }
    dl dt.prop.implied::before {
      content: "\0025CF"; /* BLACK CIRCLE */
    }
    dl dt.prop.immediate::before {
      content: "="; /* or "\002338" */
    }
    dl dt.prop.sharedefine::after {
      content: "\0021F1"; /* NORTH WEST ARROW TO CORNER */
      margin-left:4px; color: green;
      /* content: "\01F517"; /* LINK SYMBOL */
    }
    dl dt.prop.arraycommon::after {
      content: "\0021F1\0021F2"; /* SOUTH EAST ARROW TO CORNER */
      margin-left:4px; color: green;
      /* content: "\01F587";  LINKED PAPERCLIPS */
    }
    dl dt.prop input {
      display: inline-block; margin-left: 4px;  right: 20px; position:absolute;
      background-color: LemonChiffon; width: 24em;
    }
    
    /* lists of attributes of property and includedev, like behavior, protocol, parameter, .. */
    dl dd > ul { font-size: smaller; padding-left:0;}
    dl dd > ul li {
      border-left: 1px solid BurlyWood; padding-left: 4px;
      list-style-type: none;
    }
    dl dd > ul.behavior, dl dd > ul.protocol {
        border-left: 1px solid BurlyWood;
    }
    dl dd > ul.behavior li, dl dd > ul.protocol li {
        display: inline; border-style: none;
    }
    dl dd > ul.behavior li:not(:last-of-type)::after, dl dd > ul.protocol li:not(:last-of-type)::after {
        content:",";
    }
    
    dl dd > ul.value li.string {
      white-space: pre; border-color: black;
    }
    dl dd > ul.value li.uint, dl dd > ul.value li.sint, dl dd > ul.value li.float {
      text-align: right; max-width:40ex; border-bottom: 1px dotted BurlyWood;
    }

    table.db { border: 1px solid BurlyWood; margin-top: 1px; }
    table.db th { background-color: LemonChiffon; border-bottom: 1px solid BurlyWood; padding: 2px; }
    table.db td { padding: 2px; }
    table.db td + td { border-left: 1px solid BurlyWood; }
    table.db td.dbr { text-align: right; }
    span.alternatefor { margin-left: 1ex; }
    span.error { margin-left: 1ex; margin-right: 1ex; color: red; font-weight: bold; font-style: italic;}
    span.extends { margin-left: 1ex; border-bottom: 1px solid BurlyWood; }
    @media print {
      /*dl dt.closed + dd { display: block !important; }*/
    }
    </style>
  </head>
  <body>
    <xsl:apply-templates select="ddl:DDL"/>
    <script type="text/javascript"><![CDATA[
    function dtclick(e) {
      if (e.currentTarget == e.target) {
        this.classList.toggle("closed");
      }
      else if (e.target.tagName == 'SPAN') {
        this.classList.toggle("closed");
        var closed = this.classList.contains("closed");
        items = this.nextElementSibling.getElementsByTagName("dt");
        for (var i = 0; i < items.length; i++) {
          var dt = items[i];
          dt.classList.toggle("closed");
        }
      }
    }
    var items = document.getElementsByTagName('dt');
    for (var i = 0; i < items.length; i++) {
      var dt = items[i];
      dt.addEventListener('click',dtclick);
      dt.classList.add("closed");
    }
    ]]></script>
  </body>
</html>
</xsl:template>

<!-- === ddl module header === -->

<xsl:template match="ddl:behaviorset | ddl:device | ddl:languageset" mode="header">
  <header class="module"><xsl:attribute name="id"><xsl:apply-templates select="." mode="id"/></xsl:attribute>
    <h1><xsl:apply-templates select="." mode="title"/></h1>
      <table>
      <tr><th>module</th><td><xsl:value-of select="concat('ACN Device Description Language ',../@version,' Module ')"/></td></tr>
      <tr><th><xsl:value-of select="name()"/></th><td><b><xsl:apply-templates select="." mode="id"/></b></td></tr>
      <xsl:apply-templates select="@UUID" mode="tr"/>
      <xsl:apply-templates select="ddl:parameter" mode="tr"/>
      <xsl:apply-templates select="ddl:label" mode="tr"/>
      <xsl:apply-templates select="@date" mode="tr"/>
      <xsl:apply-templates select="@provider" mode="tr"/>
      <xsl:apply-templates select="ddl:extends" mode="tr"/>
      <xsl:apply-templates select="ddl:alternatefor" mode="tr"/>
      <xsl:if test="ddl:UUIDname">
        <tr><th><xsl:value-of select="concat(count(ddl:UUIDname),' modules')"/></th><td><xsl:apply-templates select="ddl:UUIDname" mode="link-in-list">
                <xsl:sort select="@name" data-type="text" order="ascending"/>
            </xsl:apply-templates></td></tr>
      </xsl:if>
      <xsl:apply-templates select="." mode="tr"/>
      </table>
  </header>
</xsl:template>

<!-- === ddl:alternatefor === -->

<xsl:template match="ddl:alternatefor">
    <xsl:apply-templates select="." mode="link"/>
</xsl:template>

<xsl:template match="ddl:alternatefor" mode="tr">
    <tr><th>replaces</th><td><xsl:apply-templates select="."/></td></tr>
</xsl:template>

<!-- === ddl:behavior === -->

<xsl:template match="ddl:behavior">
    <xsl:apply-templates select="." mode="link"/>
</xsl:template>

<xsl:template match="ddl:behavior" mode="li">
    <li><xsl:apply-templates select="."/></li>
</xsl:template>

<!-- === ddl:behaviordef === -->

<xsl:template match="ddl:behaviordef">
  <section class="behaviordef"><xsl:attribute name="id"><xsl:apply-templates select="." mode="id"/></xsl:attribute><header>
    <table><tbody>
    <tr><th><xsl:value-of select="concat(position(),' behavior')"/></th><td><b><xsl:value-of select="@name"/></b></td></tr>
    <xsl:apply-templates select="ddl:label" mode="tr"/>
    <xsl:apply-templates select="ddl:refines" mode="tr"/>
    </tbody></table></header>
    <xsl:apply-templates select="ddl:section"/>
  </section>
</xsl:template>

<!-- === ddl:behaviorset (module) === -->

<xsl:template match="ddl:behaviorset">
    <xsl:apply-templates select="." mode="header"/>
    <main><xsl:apply-templates select="ddl:behaviordef" /></main>
</xsl:template>

<xsl:template match="ddl:behaviorset" mode="tr">
    <tr><th><xsl:value-of select="concat(count(ddl:behaviordef),' behaviors')"/></th><td><xsl:apply-templates select="ddl:behaviordef" mode="link-in-list">
        <xsl:sort select="@name" data-type="text" order="ascending"/>
    </xsl:apply-templates></td></tr>
</xsl:template>

<!-- === ddl:device (module) === -->

<xsl:template match="ddl:device">
  <xsl:apply-templates select="." mode="header"/>
  <main>
    <!-- output a kind of treeview of the properties -->
    <section class="appliance"><header><h1><xsl:apply-templates select="." mode="title"/>  Appliance</h1></header><xsl:apply-templates select="." mode="tree"/></section>
    <xsl:apply-templates select="ddl:useprotocol"/>
  </main>
  <!--footer><pre><xsl:apply-templates select="$root-device-object" mode="full-node-tree"/></pre></footer-->
</xsl:template>

<xsl:template match="ddl:device|ddl:property" mode="tree">
  <xsl:param name="path" select="''"/>
  <!-- output a treeview of the properties -->
  <xsl:variable name="list"><xsl:apply-templates select="ddl:property|ddl:includedev|ddl:propertypointer" mode="tree-item">
      <xsl:with-param name="path" select="$path"/>
  </xsl:apply-templates></xsl:variable>
  <xsl:if test="$list != ''"><dl><xsl:copy-of select="$list"/></dl></xsl:if>
</xsl:template>

<!-- device additional header data -->
<xsl:template match="ddl:device" mode="tr">
  <xsl:variable name="members" select="ddl:property[@valuetype!='immediate']|ddl:includedev"/>
  <tr><th><xsl:value-of select="concat(count($members),'&#160;members')"/></th><td><xsl:apply-templates select="$members" mode="link-in-list">
      <xsl:sort select="@xml:id" data-type="text" order="ascending"/>
  </xsl:apply-templates><xsl:value-of select="concat(' (with ',count($root-device-object//ddl:property),' properties in total)')"/></td></tr>
  <tr><th><xsl:value-of select="concat(count(ddl:useprotocol),'&#160;protocols')"/></th><td><xsl:apply-templates select="ddl:useprotocol" mode="link-in-list">
      <xsl:sort select="@name" data-type="text" order="ascending"/>
  </xsl:apply-templates></td></tr>
  
  <!-- the number of alarms (properties.with.behavior 'alarm...') -->
  <xsl:variable name="alarms" select="$root-device-object//ddl:property[ddl:behavior[starts-with(@name,'alarm') and @set='acn.dms.bset']]"/>
  <xsl:if test="$alarms and false()">
      <tr><th><xsl:value-of select="concat(count($alarms),' alarms')"/></th><td>
      <table class="db">
      <tr><th></th><th>alarm property</th><th>data type</th><th>behavior</th></tr>
      <xsl:apply-templates select="$alarms" mode="tr">
          <!--xsl:sort select="@xml:id" data-type="text" order="ascending"/-->
      </xsl:apply-templates>
      </table></td></tr>
  </xsl:if>
  <!-- the number of faults -->
  <xsl:variable name="faults" select="$root-device-object//ddl:property[ddl:behavior[starts-with(@name,'fault') and @set='acn.dms.bset']]"/>
  <xsl:if test="$faults and false()">
      <tr><th><xsl:value-of select="concat(count($faults),' faults')"/></th><td>
      <table class="db">
      <tr><th></th><th>fault property</th><th>data type</th><th>behavior</th></tr>
      <xsl:apply-templates select="$faults" mode="tr">
          <!--xsl:sort select="@xml:id" data-type="text" order="ascending"/-->
      </xsl:apply-templates>
      </table></td></tr>
  </xsl:if>
  <!-- bitmaps -->
  <!--xsl:variable name="bitmaps" select="$root-device-object//ddl:property[ddl:behavior[starts-with(@name,'type.bitmap32') and @set='acn.dms.bset']]"/-->
  <xsl:variable name="bitmaps" select="$root-device-object//ddl:property[ddl:behavior[starts-with(@name,'type.bitmap32') and @set='acn.dms.bset']]"/>
  <xsl:if test="$bitmaps and false()">
      <tr><th><xsl:value-of select="concat(count($bitmaps),' bitmaps')"/></th><td>
      <table class="db">
      <tr><th></th><th>bitmap property</th><th>data type</th><th>behavior</th></tr>
      <xsl:apply-templates select="$bitmaps" mode="tr">
          <!--xsl:sort select="@xml:id" data-type="text" order="ascending"/-->
      </xsl:apply-templates>
      </table></td></tr>
  </xsl:if>
</xsl:template>

<!-- === @date === -->

<xsl:template match="@date" mode="tr">
  <tr><th>date</th><td><xsl:apply-templates select="."/></td></tr>
</xsl:template>

<!-- === ddl:extends === -->

<xsl:template match="ddl:extends">
  <xsl:apply-templates select="." mode="link"/>
</xsl:template>

<xsl:template match="ddl:extends" mode="tr">
  <tr><th>extends</th><td><xsl:apply-templates select="."/></td></tr>
</xsl:template>


<!-- === ddl:hd === -->

<xsl:template match="ddl:hd">
    <h4><xsl:apply-templates select="xml:id"/><xsl:value-of select="."/></h4>
</xsl:template>

<!-- === ddl:label === -->

<xsl:template match="ddl:label">
    <xsl:apply-templates select="." mode="text"/>
</xsl:template>

<xsl:template match="ddl:label" mode="tr">
    <tr><th>label</th><td>
    <xsl:choose>
      <xsl:when test="@set and @key">
        <xsl:variable name="url"><xsl:apply-templates select="@set" mode="url"/></xsl:variable>
        <a href="{$url}#{@key}" title="{$url}#{@key}"><xsl:apply-templates select="." mode="text"/></a>
      </xsl:when>
      <xsl:otherwise><xsl:apply-templates select="." mode="text"/></xsl:otherwise>
    </xsl:choose>
  </td></tr>
</xsl:template>

<!-- === ddl:language === -->

<xsl:template match="ddl:language">
  <div class="language">
    <xsl:attribute name="id"><xsl:apply-templates select="." mode="id"/></xsl:attribute>
    <h2><xsl:value-of select="concat('Language ',@lang)"/></h2>
    <xsl:variable name="altlang-id" select="@altlang"/>
    <xsl:variable name="altlang" select="../ddl:language[@lang=$altlang-id]"/>

  <table class="db" cellpadding="4" cellspacing="0">
  <thead><xsl:choose>
      <xsl:when test="$altlang">
        <tr><th></th><th>string</th><th>value</th><th>alt value</th></tr>
      </xsl:when>
      <xsl:otherwise>
        <tr><th></th><th>string</th><th>value</th></tr>
      </xsl:otherwise>
  </xsl:choose></thead>

  <tbody><xsl:apply-templates select="ddl:string" mode="language">
        <xsl:with-param name="altlang" select="$altlang"/>
      <xsl:sort select="@key" data-type="text" order="ascending"/>
    </xsl:apply-templates></tbody>
  </table>
  </div>
</xsl:template>

<!-- === ddl:languageset (module) === -->

<xsl:template match="ddl:languageset">
    <xsl:apply-templates select="." mode="header"/>
    <main><xsl:apply-templates select="ddl:language" /></main>
</xsl:template>

<xsl:template match="ddl:languageset" mode="tr">
    <tr><th><xsl:value-of select="concat(count(ddl:language),' languages')"/></th><td><xsl:apply-templates select="ddl:language" mode="link-in-list">
        <xsl:sort select="@lang" data-type="text" order="ascending"/>
    </xsl:apply-templates></td></tr>
</xsl:template>

<!-- === ddl:p === -->

<xsl:template match="ddl:p">
    <p><xsl:copy-of select="@xml:space|@xml:id"/><xsl:if test="@xml:space = 'preserve'">
		<xsl:attribute name="style">white-space:pre; font-family:monospace</xsl:attribute>
	</xsl:if><xsl:apply-templates select="node()"/></p>
</xsl:template>

<!-- === ddl:includedev === -->

<xsl:template match="ddl:includedev" mode="tree-item">
  <xsl:param name="path" select="''"/>
    <xsl:variable name="id"><xsl:apply-templates select="." mode="id"/></xsl:variable>
    <xsl:variable name="full-name" select="concat($path,$id)"/>
    <xsl:variable name="url"><xsl:apply-templates select="@UUID" mode="url"/></xsl:variable>
  <dt id="{$full-name}" class="device closed"><a href="{$url}" title="{$url}"><xsl:value-of select="@UUID"/></a>
  <span class="id" title="{$full-name}"><xsl:apply-templates select="." mode="name"/></span><label title="{$id}"><xsl:apply-templates select="." mode="title"/></label></dt>
  <dd>
    <xsl:apply-templates select="." mode="parameters"/>
    <xsl:apply-templates select="." mode="protocols"/>
        <xsl:variable name="source-url"><xsl:apply-templates select="@UUID" mode="document-url"/></xsl:variable>
        <xsl:variable name="device" select="document($source-url)/ddl:DDL/ddl:device"/>
    <xsl:apply-templates select="$device" mode="tree">
      <xsl:with-param name="path" select="concat($full-name,'.')"/>
    </xsl:apply-templates>
  </dd>
</xsl:template>

<xsl:template match="ddl:includedev" mode="parameters">
    <xsl:variable name="items"><xsl:apply-templates select="ddl:setparam" mode="li"/></xsl:variable>
  <xsl:if test="$items != ''"><ul class="parameter"><xsl:copy-of select="$items"/></ul></xsl:if>
</xsl:template>

<xsl:template match="ddl:includedev|ddl:property" mode="protocols">
    <xsl:variable name="items"><xsl:apply-templates select="ddl:protocol" mode="li"/></xsl:variable>
  <xsl:if test="$items != ''"><ul class="protocol"><xsl:copy-of select="$items"/></ul></xsl:if>
</xsl:template>

<!-- === ddl:parameter === -->

<xsl:template match="ddl:parameter" mode="tr">
    <tr><th>parameter</th><td><i><xsl:value-of select="@name"/></i><xsl:if test="ddl:label"><xsl:text>: </xsl:text><xsl:apply-templates select="ddl:label"/></xsl:if></td></tr>
</xsl:template>

<!-- === ddl:property === -->

<xsl:template match="ddl:property" mode="tree-item">
  <xsl:param name="path" select="''"/>
    <xsl:variable name="id"><xsl:apply-templates select="." mode="id"/></xsl:variable>
    <xsl:variable name="full-name" select="concat($path,$id)"/>
    <xsl:variable name="share"><xsl:choose><xsl:when test="@sharedefine='arraycommon'"> arraycommon</xsl:when><xsl:when test="@sharedefine"> sharedefine</xsl:when></xsl:choose></xsl:variable>
  <xsl:variable name="value"><xsl:apply-templates select="." mode="tree-value">
    <xsl:with-param name="full-name" select="$full-name"/>
  </xsl:apply-templates></xsl:variable>

    <dt id="{$full-name}" class="prop {@valuetype}{$share}"><span class="id" title="{$full-name}"><xsl:apply-templates select="." mode="name"/></span>
    <label><xsl:if test="$value"><xsl:attribute name="for"><xsl:value-of select="concat($full-name,'.value')"/></xsl:attribute></xsl:if>
  <xsl:apply-templates select="." mode="title"/></label><xsl:copy-of select="$value"/></dt>
  <dd>
    <xsl:apply-templates select="." mode="behaviors"/>
    <xsl:apply-templates select="." mode="values"/>
    <xsl:apply-templates select="." mode="protocols"/>
    <xsl:apply-templates select="." mode="tree">
      <xsl:with-param name="path" select="concat($full-name,'.')"/>
    </xsl:apply-templates>
  </dd>
</xsl:template>

<xsl:template match="ddl:property" mode="tree-value">
  <xsl:param name="full-name" select="''"/>
</xsl:template>

<xsl:template match="ddl:property[(@valuetype='immediate') and not(ddl:behavior[@name='description'])]" mode="tree-value">
  <xsl:param name="full-name" select="''"/>
  <xsl:variable name="value"><xsl:apply-templates select="ddl:value"/></xsl:variable>
  <xsl:if test="count(ddl:value) = 1">
    <input id="{$full-name}.value" name="{$full-name}" readonly="readonly" value="{$value}"/>
  </xsl:if>
</xsl:template>

<xsl:template match="ddl:property[(@valuetype='network')]" mode="tree-value">
  <xsl:param name="full-name" select="''"/>
  <xsl:variable name="value"><xsl:apply-templates select="." mode="JSON.value"/></xsl:variable>
  <input id="{$full-name}.value" name="{$full-name}" placeholder="{$value}"/>
</xsl:template>

<xsl:template match="ddl:property" mode="behaviors">
    <xsl:variable name="items"><xsl:apply-templates select="ddl:behavior" mode="li"/></xsl:variable>
  <xsl:if test="$items != ''"><ul class="behavior"><xsl:copy-of select="$items"/></ul></xsl:if>
</xsl:template>

<xsl:template match="ddl:property" mode="values">
    <xsl:variable name="items"><xsl:apply-templates select="ddl:value" mode="li"/></xsl:variable>
  <xsl:if test="$items != ''"><ul class="value"><xsl:copy-of select="$items"/></ul></xsl:if>
</xsl:template>

<xsl:template match="ddl:property" mode="tr">
    <tr><td class="dbr"><xsl:value-of select="position()"/></td>
    <td><xsl:apply-templates select="." mode="deep-link"/></td>
    <td><xsl:apply-templates select="." mode="type"/></td>
    <td><xsl:apply-templates select="ddl:behavior" mode="link-in-list"/></td></tr>
</xsl:template>

<xsl:template match="ddl:property" mode="parameter-tr">
    <tr><td class="dbr"><xsl:value-of select="position()"/></td>
    <td><xsl:apply-templates select="." mode="deep-link"/></td>
    <td><xsl:apply-templates select="." mode="type"/></td>

    <td class="dbr"><xsl:apply-templates select="ddl:property[(@valuetype='immediate') and ddl:behavior[@name='limitMinInc']]" mode="JSON.value"/></td>
    <td class="dbr"><xsl:apply-templates select="ddl:property[(@valuetype='immediate') and ddl:behavior[@name='initializer']]" mode="JSON.value"/></td>
    <td class="dbr"><xsl:apply-templates select="ddl:property[(@valuetype='immediate') and ddl:behavior[@name='limitMaxInc']]" mode="JSON.value"/></td>
    <td><xsl:apply-templates select="ddl:behavior" mode="link-in-list"/></td>
    <td><xsl:apply-templates select="ddl:label" mode="text"/></td></tr>
</xsl:template>

<!-- === ddl:propertypointer === -->

<xsl:template match="ddl:propertypointer">
    <xsl:apply-templates select="." mode="link"/>
</xsl:template>

<xsl:template match="ddl:propertypointer" mode="tree-item">
  <xsl:param name="path" select="''"/>

    <dt class="prop"><xsl:apply-templates select="."/></dt>
  <dd></dd>
</xsl:template>

<!-- === ddl:propref_DMP === -->

<xsl:template match="ddl:propref_DMP">
    <xsl:if test="string(../@name) != 'ESTA.DMP'"><span class="error">protocol should be ESTA.DMP</span></xsl:if>
    <xsl:variable name="abs">
        <xsl:choose><xsl:when test="@abs='true'"><xsl:value-of select="'absolute'"/></xsl:when><xsl:otherwise><xsl:value-of select="'relative'"/></xsl:otherwise></xsl:choose>
    </xsl:variable>
    <xsl:variable name="access"><xsl:apply-templates select="." mode="access"/></xsl:variable>
    <xsl:variable name="loc"><xsl:apply-templates select="@loc" mode="dechex"/></xsl:variable>
    <xsl:variable name="size"><xsl:apply-templates select="." mode="size"/></xsl:variable>
    <xsl:value-of select="concat(': address=',$loc,' (',$abs,'); access=',$access,'; size=',$size,'.')"/>
</xsl:template>

<xsl:template match="ddl:propref_DMP" mode="DMP-tr">
    <xsl:variable name="property" select="(ancestor::ddl:property|ancestor::ddl:includedev)[1]"/>
    <!-- todo: recursively include properties of child device -->
    <tr><td align="right"><xsl:apply-templates select="@loc" mode="dechex"/></td><td><xsl:apply-templates select="$property" mode="link"/></td>
    <td><xsl:apply-templates select="$property/ddl:behavior"/></td>
    <td><xsl:apply-templates select="." mode="access"/></td><td align="right"><xsl:apply-templates select="." mode="size"/></td></tr>
</xsl:template>

<xsl:template match="ddl:propref_DMP" mode="access">
    <xsl:variable name="read"><xsl:choose><xsl:when test="@read='true'"><xsl:value-of select="'read'"/></xsl:when><xsl:otherwise><xsl:value-of select="'-'"/></xsl:otherwise></xsl:choose></xsl:variable>
    <xsl:variable name="write"><xsl:choose><xsl:when test="@write='true'"><xsl:value-of select="'write'"/></xsl:when><xsl:otherwise><xsl:value-of select="'-'"/></xsl:otherwise></xsl:choose></xsl:variable>
    <xsl:variable name="event"><xsl:choose><xsl:when test="@event='true'"><xsl:value-of select="'event'"/></xsl:when><xsl:otherwise><xsl:value-of select="'-'"/></xsl:otherwise></xsl:choose></xsl:variable>
    <xsl:value-of select="concat($read,'/',$write,'/',$event)"/>
</xsl:template>

<xsl:template match="ddl:propref_DMP" mode="size">
    <xsl:choose>
        <xsl:when test="@varsize='true'"><xsl:value-of select="'variable'"/></xsl:when>
        <xsl:when test="not(@size) or (number(@size)=1)"><xsl:value-of select="'1 byte'"/></xsl:when>
        <xsl:otherwise><xsl:value-of select="concat(@size,' bytes')"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<!-- === ddl:propref_IO === -->

<xsl:template match="ddl:propref_IO">
    <xsl:if test="not(starts-with(string(../@name),'IO'))"><span class="error">protocol should be a IO protocol</span></xsl:if>
    <xsl:variable name="range"><xsl:apply-templates select="." mode="range"/></xsl:variable>
    <xsl:choose>
        <xsl:when test="position() = 1"><xsl:value-of select="': '"/></xsl:when>
        <xsl:otherwise><xsl:value-of select="', '"/></xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="concat('channel=',@module,'.',@type,'[',@channel,$range,']')"/>
</xsl:template>

<xsl:template match="ddl:propref_IO" mode="tr">
    <xsl:variable name="property" select="../.."/>
    <tr><td align="right"><xsl:value-of select="@module"/></td><td><xsl:value-of select="@type"/></td>
    <td align="right"><xsl:apply-templates select="." mode="channel"/></td>
    <td><xsl:apply-templates select="$property" mode="deep-link"/></td>
    <td><xsl:apply-templates select="$property" mode="type"/></td>
    <td><xsl:apply-templates select="$property/ddl:behavior" mode="link-in-list"/></td>
    <td><xsl:apply-templates select="." mode="flags"/></td></tr>
</xsl:template>

<!-- === ddl:propref_Modbus === -->

<xsl:template match="ddl:propref_Modbus">
    <xsl:variable name="protocol" select="string(../@name)"/>
    <xsl:if test="not(starts-with(string(../@name),'Modbus'))"><span class="error">protocol <xsl:value-of select="../@name"/> should be Modbus</span></xsl:if>
    <xsl:variable name="address"><xsl:apply-templates select="." mode="address"/></xsl:variable>
    <xsl:variable name="range">
        <xsl:if test="number(@size) &gt; 1"><xsl:value-of select="concat('..',number($address) + number(@size) - 1)"/></xsl:if>
    </xsl:variable>
    <xsl:if test="position()=1"><xsl:value-of select="': '"/></xsl:if>
    <xsl:if test="position() &gt; 1"><xsl:value-of select="', '"/></xsl:if>
    <xsl:value-of select="concat(@type,'[',$address,$range,']')"/>
</xsl:template>

<xsl:template match="ddl:propref_Modbus" mode="tr">
    <xsl:variable name="property" select="../.."/><!-- get the ancestor property|includedev node -->
    <xsl:variable name="address"><xsl:apply-templates select="." mode="address"/></xsl:variable>
    <xsl:variable name="size"><xsl:apply-templates select="." mode="size"/></xsl:variable>
    <xsl:variable name="addresshex">
        <xsl:call-template name="FormatHex">
            <xsl:with-param name="number" select="number($address)"/>
        </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="range">
        <xsl:if test="number($size) &gt; 1"><xsl:value-of select="concat('..',number($address) + number($size) - 1)"/></xsl:if>
    </xsl:variable>
    <tr><td><xsl:value-of select="@type"/></td><td align="right"><xsl:value-of select="concat($address,$range)"/></td>
    <td align="right"><xsl:value-of select="$addresshex"/></td><td align="right"><xsl:apply-templates select="." mode="size-unit"/></td>
    <td><xsl:apply-templates select="$property" mode="deep-link"/></td><td><xsl:apply-templates select="$property/ddl:behavior" mode="link-in-list"/></td>
    <td><xsl:apply-templates select="." mode="access"/></td></tr>
</xsl:template>

<!-- === ddl:protocol === -->

<xsl:template match="ddl:protocol" mode="tr">
    <xsl:variable name="name" select="@name"/>
  <tr><th>protocol</th><td><xsl:if test="not(preceding::ddl:useprotocol[@name=$name])"><span class="error">unknown protocol:</span></xsl:if>
  <xsl:value-of select="@name"/><xsl:apply-templates select="*"/></td></tr>
</xsl:template>

<xsl:template match="ddl:protocol" mode="li">
    <xsl:variable name="name" select="@name"/>
  <li><xsl:if test="not(preceding::ddl:useprotocol[@name=$name])"><span class="error">unknown protocol:</span></xsl:if>
  <xsl:value-of select="@name"/><xsl:apply-templates select="*"/></li>
</xsl:template>

<!-- === @provider === -->

<xsl:template match="@provider">
    <xsl:apply-templates select="." mode="link"/>
</xsl:template>

<xsl:template match="@provider" mode="tr">
    <tr><th>provider</th><td><xsl:apply-templates select="."/></td></tr>
</xsl:template>

<!-- === ddl:refines === -->

<xsl:template match="ddl:refines">
    <xsl:apply-templates select="." mode="link"/>
</xsl:template>

<xsl:template match="ddl:refines" mode="tr">
    <tr><th>refines</th><td><xsl:apply-templates select="."/></td></tr>
</xsl:template>

<!-- === ddl:section === -->

<xsl:template match="ddl:section">
  <section>
    <xsl:apply-templates select="ddl:hd"/>
    <xsl:apply-templates select="ddl:section | ddl:p | html:*"/>
  </section>
</xsl:template>

<!-- === html:* (actually only html:p and html:section should be used) === -->

<xsl:template match="html:*">
	<xsl:element name="{local-name(.)}"><xsl:copy-of select="@*"/><xsl:apply-templates/></xsl:element>
</xsl:template>

<!-- === ddl:setparam === -->

<xsl:template match="ddl:setparam" mode="li">
    <li><i><xsl:value-of select="@name"/></i><xsl:value-of select="concat(' := &quot;',.,'&quot;')"/></li>
</xsl:template>

<!-- === ddl:string === -->

<xsl:template match="ddl:string" mode="language">
    <xsl:param name="altlang"/>
    <xsl:choose>
        <xsl:when test="$altlang">
            <xsl:variable name="key" select="@key"/>
            <tr><td><xsl:value-of select="position()"/></td><td><xsl:value-of select="@key"/></td><td><xsl:value-of select="."/></td><td><xsl:value-of select="$altlang/ddl:string[@key=$key]"/></td></tr>
        </xsl:when>
        <xsl:otherwise>
            <tr id="{@key}"><td><xsl:value-of select="position()"/></td><td><xsl:value-of select="@key"/></td><td><xsl:value-of select="."/></td></tr>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<!-- === ddl:useprotocol === -->

<xsl:template match="ddl:useprotocol">
    <section class="useprotocol"><xsl:attribute name="id"><xsl:apply-templates select="." mode="id"/></xsl:attribute><header>
      <table>
      <tr><th><xsl:value-of select="concat(position(),' protocol')"/></th><td><b><xsl:value-of select="@name"/></b></td></tr>
      </table></header>
      <xsl:apply-templates select="." mode="overview"/>
    </section>
</xsl:template>

<xsl:template match="ddl:useprotocol[@name='ESTA.DMP']" mode="overview">
  <!-- create a table for ESTA.DMP properties ordered on address -->
    <table class="db">
    <tr><th>address</th><th>property</th><th>behavior</th><th>access</th><th>size</th></tr>
    <xsl:apply-templates select="../*/ddl:protocol/ddl:propref_DMP" mode="DMP-tr">
        <xsl:sort select="@loc" data-type="number" order="ascending"/>
    </xsl:apply-templates>
    </table>
</xsl:template>

<xsl:template match="ddl:useprotocol[starts-with(@name,'IO')]" mode="overview">
    <xsl:variable name="name" select="@name"/>
    <table class="db">
    <tr><th>module</th><th>type</th><th>channel</th><th>property</th><th>data type</th><th>behavior</th><th>flags</th></tr>
    <xsl:apply-templates select="$root-device-object//ddl:protocol[@name=$name]/ddl:propref_IO" mode="tr">
        <xsl:sort select="@module" data-type="text" order="ascending"/>
        <xsl:sort select="@type" data-type="text" order="ascending"/>
        <xsl:sort select="@channel" data-type="number" order="ascending"/>
    </xsl:apply-templates>
    </table>
</xsl:template>

<xsl:template match="ddl:useprotocol[starts-with(@name,'DMS')]" mode="overview">
    <xsl:variable name="name" select="@name"/>
    <xsl:variable name="props" select="../*/ddl:protocol[@name=$name]/.."/>
    <xsl:if test="$props">
        <xsl:variable name="indent" select="'  '"/>
        <pre><xsl:value-of select="concat('&#xA;','{','&#xA;')"/>
        <xsl:apply-templates select="$props" mode="JSON">
            <xsl:with-param name="indent" select="$indent"/>
        </xsl:apply-templates>
        <xsl:value-of select="concat('&#xA;','}')"/></pre>
    </xsl:if>
</xsl:template>

<xsl:template match="ddl:useprotocol[starts-with(@name,'CANopen')]" mode="overview">
    <xsl:variable name="name" select="@name"/>
    <table class="db">
    <tr><th>node</th><th>index</th><th>sub</th><th>cat</th><th>property</th><th>behavior</th><th>access</th><th>pdo</th></tr>
    <xsl:apply-templates select="$root-device-object//ddl:protocol[@name=$name]/cia:CANopen" mode="tr">
        <xsl:sort select="@index" data-type="text" order="ascending"/>
        <xsl:sort select="@sub" data-type="number" order="ascending"/>
    </xsl:apply-templates>
    </table>
</xsl:template>

<xsl:template match="ddl:useprotocol[starts-with(@name,'Modbus')]" mode="overview">
    <xsl:variable name="name" select="@name"/>
    <table class="db">
    <tr><th>type</th><th colspan="2">address</th><th>size</th><th>property</th><th>behavior</th><th>access</th></tr>
    <xsl:apply-templates select="$root-device-object//ddl:protocol[@name=$name]/ddl:propref_Modbus" mode="tr">
        <xsl:sort select="@type = 'RDI'" data-type="number" order="ascending"/>
        <xsl:sort select="@address" data-type="number" order="ascending"/>
    </xsl:apply-templates>
    </table>
</xsl:template>

<xsl:template match="ddl:useprotocol[starts-with(@name,'KROHNE.GDC')]" mode="overview">
    <xsl:variable name="name" select="@name"/>
    <table class="db">
    <tr><th>objectNo</th><th>subNo</th><th>offset</th><th>property</th><th>behavior</th><th>access</th></tr>
    <xsl:apply-templates select="$root-device-object//ddl:protocol[@name=$name]/krohne:GDC" mode="tr">
        <xsl:sort select="@objectNo" data-type="number" order="ascending"/>
        <xsl:sort select="@subNo" data-type="number" order="ascending"/>
        <xsl:sort select="@offset" data-type="number" order="ascending"/>
    </xsl:apply-templates>
    </table>
</xsl:template>

<xsl:template match="krohne:GDC" mode="tr">
	<!--xsl:variable name="property" select="(ancestor::ddl:property)[1]"/-->
	<xsl:variable name="property" select="../.."/>
	<!-- todo: recursively include properties of child device -->
	<tr>
	<td align="right"><xsl:apply-templates select="@objectNo" mode="dechex"/></td>
	<td align="right"><xsl:apply-templates select="@subNo" mode="dechex"/></td>
	<td align="right"><xsl:apply-templates select="@offset" mode="dechex"/></td>
	<td><xsl:apply-templates select="$property" mode="link"/></td>
	<td><xsl:apply-templates select="$property/ddl:behavior" mode="link-in-list"/></td>
	<td><!--xsl:apply-templates select="." mode="access"/--></td></tr>
</xsl:template>

<!-- === @UUID | @set (module reference UUID or UUIDname === -->

<xsl:template match="@UUID" mode="tr">
    <tr><th>uuid</th><td><xsl:apply-templates select="."/></td></tr>
</xsl:template>


<!-- === ddl:UUIDname === -->

<!-- === ddl:value === -->

<xsl:template match="ddl:value" mode="li">
  <li class="{@type}"><xsl:apply-templates select="."/></li>
</xsl:template>

</xsl:stylesheet>